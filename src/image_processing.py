import tensorflow as tf
from PIL import Image
import numpy as np
import os, gdown
from .utils import get_url_images_in_text, FixedDropout
from dotenv import load_dotenv
from tensorflow_addons.metrics import F1Score


from torchvision import transforms
import torch
import sklearn
import pickle
import ultralytics
from ultralytics import YOLO


import time

load_dotenv() 

MODEL_PATH = os.getenv('MODEL_PATH')
CLASS_NAMES = ['Apple___Apple_scab',
 'Apple___Black_rot',
 'Apple___Cedar_apple_rust',
 'Apple___healthy',
 'Blueberry___healthy',
 'Cherry_(including_sour)___Powdery_mildew',
 'Cherry_(including_sour)___healthy',
 'Corn_(maize)___Cercospora_leaf_spot Gray_leaf_spot',
 'Corn_(maize)___Common_rust_',
 'Corn_(maize)___Northern_Leaf_Blight',
 'Corn_(maize)___healthy',
 'Grape___Black_rot',
 'Grape___Esca_(Black_Measles)',
 'Grape___Leaf_blight_(Isariopsis_Leaf_Spot)',
 'Grape___healthy',
 'Orange___Haunglongbing_(Citrus_greening)',
 'Peach___Bacterial_spot',
 'Peach___healthy',
 'Pepper,_bell___Bacterial_spot',
 'Pepper,_bell___healthy',
 'Potato___Early_blight',
 'Potato___Late_blight',
 'Potato___healthy',
 'Raspberry___healthy',
 'Soybean___healthy',
 'Squash___Powdery_mildew',
 'Strawberry___Leaf_scorch',
 'Strawberry___healthy',
 'Tomato___Bacterial_spot',
 'Tomato___Early_blight',
 'Tomato___Late_blight',
 'Tomato___Leaf_Mold',
 'Tomato___Septoria_leaf_spot',
 'Tomato___Spider_mites Two-spotted_spider_mite',
 'Tomato___Target_Spot',
 'Tomato___Tomato_Yellow_Leaf_Curl_Virus',
 'Tomato___Tomato_mosaic_virus',
 'Tomato___healthy']


try:
    if MODEL_PATH not in os.listdir('.'):
        os.makedirs(MODEL_PATH)
except OSError as e: # name the Exception `e`
        print( "Failed with:", e.strerror) # look what it says
        print( "Error code:", e.code )


def download_model(drive_url, model_name, ext='pkl'):
    """Downloads a model from Google Drive if not already present."""
    model_path = os.path.join(MODEL_PATH, f"{model_name}.{ext}")
    if not os.path.exists(model_path):
        print(f"Downloading model: {model_name}")
        gdown.download(
            drive_url, 
            model_path, 
            quiet=False,
            fuzzy=True # extract drive id from drive URL 
        ) 


def load_image(file_url: str, _load_func):
    file_path = gdown.download(file_url, quiet=False,)  
    img = _load_func(file_path)
    try:
        os.remove(file_path) # Remove the cached file
    except OSError as e: # name the Exception `e`
        print( "Failed with:", e.strerror) # look what it says
        print( "Error code:", e.code )
    return img


def load_model_tf(model_name:str):
    """
    Download trained model and load tensorflow model
    Params:
    `drive_url`: an URL generated by Google Drive when clicked 'Copy link' in share. Please configure view accessibility to "Anyone with the link"
    `model_name`: name of the model
    """
    model_path = os.path.join(MODEL_PATH, f'{model_name}.h5')
    try:
        model = tf.keras.models.load_model(model_path)
    except:
        # for efficientNet model
        model = tf.keras.models.load_model(
            model_path, 
            custom_objects={'FixedDropout':FixedDropout(rate=0.2)}
        )
    return model


def read_and_prep(image_path:str, _prep_func=None, fetch:bool=False):
    """
    Read an image from a path or an url 
    Params:
    `image_path`: path or url to the image
    `fetch`: if True, the server will download the file
    """
    if fetch:
        image_url = get_url_images_in_text(image_path)[0]
        if image_url:
            try:
                img = load_image(image_url, lambda img_path: tf.keras.preprocessing.image.load_img(img_path))
            except:
                return None
        else:
            print(image_path)
            print('Only support PNG and JPEG image or unencrypted file url')
            return None

    if _prep_func: 
        img = _prep_func(img) 
    return img


def _predict_tf(model, img):
    # Predict the class probabilities with img normalized to [0, 1]
    probs = model.predict(img)[0]
    # Get the predicted class index and name
    pred_class_prob = np.argmax(probs)
    pred_class_name = CLASS_NAMES[pred_class_prob]
    # Print the predicted class name and probability
    print(f'Probability: {probs[pred_class_prob]}')
    print(f'Predicted class: {pred_class_name}')

    return pred_class_name, pred_class_prob, probs


def preprocess_tf_image(img):
    img = tf.keras.preprocessing.image.smart_resize(
        img,
        size=(224, 224),
        interpolation='nearest'
    )
    img = tf.keras.preprocessing.image.img_to_array(img)
    img = np.expand_dims(img, axis=0) / 255.
    return img


def predict_tf(image_path, fetch=False, threshold=0.5, model=None):
    """
    Load, preprocess and predict an image
    """
    global CLASS_NAMES, mobilenet1
    if model is None:
        model = mobilenet1

    img = read_and_prep(image_path, preprocess_tf_image, fetch)
    if img is None:
        print("We're restricted to read the file on our server, please download the file and upload")
        return

    # Predict the class probabilities with img normalized to [0, 1]
    pred_class_name, pred_class_prob, probs = _predict_tf(model, img)

    # Find final label
    if probs[pred_class_prob] < threshold:
        pred_class_name = 'Unknown'

    tf.keras.backend.clear_session()
    del img
    return pred_class_name, probs[pred_class_prob], probs


def predict_ensemble(image_path, fetch=False, threshold=0.5):
    """
    Load, preprocess and predict an image
    """
    global CLASS_NAMES, mobilenet1, mobilenet2, efficientnet
    img = read_and_prep(image_path, preprocess_tf_image, fetch=fetch)
    if img is None:
        print("We're restricted to read the file on our server, please download the file and upload")
        return

    # Predict the class probabilities with img normalized to [0, 1]
    # first model
    print('Model 1')
    _, pred_class_prob1, probs1 = _predict_tf(mobilenet1, img)
    print('Model 2')
    # second model
    _, pred_class_prob2, probs2 = _predict_tf(mobilenet2, img)
    # ensemble
    # Get the predicted class index and name
    probs = (probs1 + probs2)/2
    pred_class_prob = np.argmax(probs)
    pred_class_name = CLASS_NAMES[pred_class_prob]
    # Find final label
    if pred_class_prob1 != pred_class_prob2 \
        or probs[pred_class_prob] < threshold:
        pred_class_name = 'Unknown'

    tf.keras.backend.clear_session()
    del img

    return pred_class_name, probs[pred_class_prob], probs


def predict_dino(file_url):
    global dinov2_vits14, svc
    load_img = lambda file_path: transform_image(Image.open(file_path))[:3].unsqueeze(0)
    with torch.no_grad():
        embedding = dinov2_vits14(load_image(file_url, load_img).to(device))
        y_pred = svc.predict(embedding)
    
    return y_pred[0]


def predict_yolo(img_url):
    global yolo_model 
    file_path = gdown.download(img_url, quiet=False,)  

    # inference
    pred = yolo_model(file_path)[0]

    # delete cache
    try:
        os.remove(file_path) # Remove the cached file
    except OSError as e: # name the Exception `e`
        print( "Failed with:", e.strerror) # look what it says
        print( "Error code:", e.code )    
    
    return pred.names[pred.probs.top1]


def predict_efficientnet(image_url):
    return predict_tf(image_url, fetch=True, threshold=0.7, model=efficientnet)

model_links = {
    'mobileNetV2_ver1': 'https://drive.google.com/file/d/18xhVHvV54WqlmincjGwwczifbtHJmHZZ/view?usp=drive_link',
    'mobileNetV2_ver2': 'https://drive.google.com/file/d/1ulDbs-PJNsMVNXEfiV2ejOFd-6h89Mnq/view?usp=drive_link',
    'efficientNet': 'https://drive.google.com/file/d/1UVdBAgm2wa62z7qAQ5raDIJQmen0AZsZ/view?usp=drive_link',
    'dino_svm': 'https://drive.google.com/file/d/1rjohQxHorqk4zAqiE1WDFe3m0DEEInx5/view?usp=drive_link',
    'yolo': 'https://drive.google.com/file/d/1yJgy-aNP_FZX_jL5CfSfixaQpxRAg9Oq/view?usp=drive_link',
}


# LOAD TENSORFLOW MODELS
download_model(model_links['mobileNetV2_ver1'], 'mobileNetV2_ver1', 'h5')
mobilenet1 = load_model_tf(
    model_name='mobileNetV2_ver1'
)


download_model(model_links['mobileNetV2_ver2'], 'mobileNetV2_ver2', 'h5')
mobilenet2 = load_model_tf(
    model_name='mobileNetV2_ver2'
)


download_model(model_links['efficientNet'], 'efficientNet', 'h5')
efficientnet = load_model_tf(
    model_name='efficientNet'
)


# LOAD DINO SVM model
download_model(model_links['dino_svm'], 'dino_svm', 'pkl')
dinov2_vits14 = torch.hub.load("facebookresearch/dinov2", "dinov2_vits14")
device = torch.device('cuda' if torch.cuda.is_available() else "cpu")
dinov2_vits14.to(device)
transform_image = transforms.Compose([transforms.ToTensor(), transforms.Resize(244), transforms.CenterCrop(224), transforms.Normalize([0.5], [0.5])])
svc = pickle.load(open(os.path.join(MODEL_PATH, 'dino_svm.pkl'), 'rb'))


# LOAD YOLO model
download_model(model_links['yolo'], 'yolo', 'pt')
yolo_model = YOLO(os.path.join(MODEL_PATH, 'yolo.pt'))